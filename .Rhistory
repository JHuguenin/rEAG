Vs <- NULL
for(i in 1:nS) Vs <- c(Vs,str_flatten(c(control,sample(VOC),control)," "))
Vs
fmr <- data.frame(File = "",
VOCconcentration = "",
VOCseq =  Vs)
fmr
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
library(rEAG)
38.4*0.29
40*0.29*2
38.4*0.29*2
library(magrittr)
library(stringr)
library(rEAG)
# import
wod <- "C:/Users/huguenin/Documents/R/rEAG_test"
ExpDes <- "Experimental_design_2019.csv"
expdes <- import.exp.design("Experimental_design_2019", wd = wod) # plan d'experience
filenames <- unique(expdes$File)  # les differents fichiers a analyser
filenames
filenames[1]
Sname = filenames[1]
control = "T"
tmP = 50
ws =25
# check ####
if (is.null(wd) == TRUE) wd <- getwd()
if (!is.character(wd)) stop("'wd' must be character")
wd = wod
# check ####
if (is.null(wd) == TRUE) wd <- getwd()
if (!is.character(wd)) stop("'wd' must be character")
if (("figures" %in% dir(wd))==FALSE) dir.create(paste0(wd,"/figures"))
if (!is.character(Sname)) stop("'Sname' must be character")
if (!is.numeric(ws)) stop("'ws' must be numeric")
if (!is.numeric(tmP)) stop("'tmP' must be numeric")
if (!is.character(control)) stop("'control' must be a character")
if (length(ws) != 1) stop("Length of 'ws' must be 1.")
if (length(tmP) != 1) stop("Length of 'tmP' must be 1.")
if (length(control) != 1) stop("Length of 'control' must be 1.")
# Importation du fichier EAG ####
eag <- read.csv(paste0(wd,"/",Sname,".csv"))[,-(1:2)] # import du fichier EAG
neag <- ncol(eag)/3  # nombre de signaux EAG
fmr <- which(Sname == expdes$File) # index dans le plan d'experience
Cvoc <- expdes$VOCconcentration[fmr] # Concentrations associees
Svoc <- expdes$VOCseq[fmr] # sequences VOC associees
# Traitement de chaque signal ####
resM <- NULL # matrice des resultats
for(k in 1:neag){ # k=1
# index effectif du fichier signal
i <- seq(length.out = neag,by = 3)[k]
# La sequence VOC
VOCseq <- str_squish(Svoc[k]) %>% str_split(" ") %>% unlist()
# recherche des pulses
pulse <- eag[,i+2] - c(eag[-1,i+2],-0.5)
dP <- data.frame(str = which(pulse == -1),
end = which(pulse == -1)+tmP) # position des pulses start et end
if(length(VOCseq) != nrow(dP) ) stop("The 'VOC sequence' of experimental design does not correspond to the number of pulses")
# name pulse
rownames(dP) <- paste0(VOCseq, ave(VOCseq, VOCseq, FUN = seq), "_c",Cvoc[k])
# calcules preliminaires
dP$X1 <- dP$str - 2*tmP # un blanc anterieur au pulse d'une duree deux fois plus longue que le pulse
dP$X2 <- dP$end + 2*tmP # idem pour le blanc ulterieur
dP$Idp <- rep(NA,nrow(dP)) # NA pour l'intensite de la depolarisation
dP$Tdp <- rep(NA,nrow(dP)) # NA pour la duree de depolaristation
matP <- matrix(NA,nrow(dP),length(dP$X1[1]:dP$X2[1])) # une matrix pour l'EAG brut du pulse elargie
matS <- matP # la meme pour le signal EAG lissee
# chaque peuf
for(j in 1:nrow(dP)) { #j=1 # pour chaque pulse de la sequence
# preparation des matrix signals
IndP <- dP$X1[j]:dP$X2[j] # les index du pulse elargie
matS[j,] <- savgol(eag[IndP,i],ws) # lissage
fmr <- matS[j,2*tmP+1] # le shift a T0
matS[j,] <- matS[j,] - fmr # suppression du shift
matP[j,] <- eag[IndP,i] - fmr # idem pour l'EAG non lissee
# caracterisation de l'impuslion
Ips <- (2*tmP):(2*tmP + 2*tmP) # de T0 à T0+2x la duree du pulse du VOC
dP$Idp[j] <- min(matS[j,Ips]) # l'intensite max de la depol
dP$Tdp[j] <- (which.min(matS[j,Ips])-2)/100 # sa duree
}
# Nettoyage des donnees
matS[,1:((ws-1)/2)] <- NA # suppression des vagues induites par le lissage
matS[,(ncol(matS)-((ws-1)/2)):ncol(matS)] <- NA # idem pour la fin du signal
Tp <- dP$X1[j]:dP$X2[j] - dP$str[j]# le temps recentre
# # Graphe control
# matplot(Tp/100,t(matS), type = "l", lwd = 2, lty = 1, col = rainbow(nrow(dP)),
#         xlab = "Time (s)", ylab = "EAG (mA)", main = paste(Sname,"\nC =",Cvoc[k]))
# matplot(Tp/100,t(matP), type = "l", lwd = 1, lty = 1, col = rainbow(nrow(dP)), add = TRUE)
# abline(v = c(0,tmP/100), col = "orange", lwd = 2, lty = 2)
# points(dP$Tdp, dP$Idp, col = "black", pch = 16)
# legend("bottomleft", legend = rownames(dP), lty = 1, lwd = 2,col = rainbow(nrow(dP)))
# Union des matrix
dP$con <- as.numeric(Cvoc[k])
dP$seq <- VOCseq
# mise en forme
colnames(matS) <- paste0("T_",Tp) # le temps
fmr <- !is.na(matS[1,]) # pour le calcul du temps lors de la partie eag ci-dessus ... ouais c'est pas ouf
matS <- matS[,!is.na(matS[1,])] # suppression des vagues du au lissage
resM <- rbind(resM,cbind(dP[,5:8], matS)) # maj de la matrice
}
library(plotly)
library(stringr)
library(pracma)
library(RColorBrewer)
library(data.table)
for(k in 1:neag){ # k=1
# index effectif du fichier signal
i <- seq(length.out = neag,by = 3)[k]
# La sequence VOC
VOCseq <- str_squish(Svoc[k]) %>% str_split(" ") %>% unlist()
# recherche des pulses
pulse <- eag[,i+2] - c(eag[-1,i+2],-0.5)
dP <- data.frame(str = which(pulse == -1),
end = which(pulse == -1)+tmP) # position des pulses start et end
if(length(VOCseq) != nrow(dP) ) stop("The 'VOC sequence' of experimental design does not correspond to the number of pulses")
# name pulse
rownames(dP) <- paste0(VOCseq, ave(VOCseq, VOCseq, FUN = seq), "_c",Cvoc[k])
# calcules preliminaires
dP$X1 <- dP$str - 2*tmP # un blanc anterieur au pulse d'une duree deux fois plus longue que le pulse
dP$X2 <- dP$end + 2*tmP # idem pour le blanc ulterieur
dP$Idp <- rep(NA,nrow(dP)) # NA pour l'intensite de la depolarisation
dP$Tdp <- rep(NA,nrow(dP)) # NA pour la duree de depolaristation
matP <- matrix(NA,nrow(dP),length(dP$X1[1]:dP$X2[1])) # une matrix pour l'EAG brut du pulse elargie
matS <- matP # la meme pour le signal EAG lissee
# chaque peuf
for(j in 1:nrow(dP)) { #j=1 # pour chaque pulse de la sequence
# preparation des matrix signals
IndP <- dP$X1[j]:dP$X2[j] # les index du pulse elargie
matS[j,] <- savgol(eag[IndP,i],ws) # lissage
fmr <- matS[j,2*tmP+1] # le shift a T0
matS[j,] <- matS[j,] - fmr # suppression du shift
matP[j,] <- eag[IndP,i] - fmr # idem pour l'EAG non lissee
# caracterisation de l'impuslion
Ips <- (2*tmP):(2*tmP + 2*tmP) # de T0 à T0+2x la duree du pulse du VOC
dP$Idp[j] <- min(matS[j,Ips]) # l'intensite max de la depol
dP$Tdp[j] <- (which.min(matS[j,Ips])-2)/100 # sa duree
}
# Nettoyage des donnees
matS[,1:((ws-1)/2)] <- NA # suppression des vagues induites par le lissage
matS[,(ncol(matS)-((ws-1)/2)):ncol(matS)] <- NA # idem pour la fin du signal
Tp <- dP$X1[j]:dP$X2[j] - dP$str[j]# le temps recentre
# # Graphe control
# matplot(Tp/100,t(matS), type = "l", lwd = 2, lty = 1, col = rainbow(nrow(dP)),
#         xlab = "Time (s)", ylab = "EAG (mA)", main = paste(Sname,"\nC =",Cvoc[k]))
# matplot(Tp/100,t(matP), type = "l", lwd = 1, lty = 1, col = rainbow(nrow(dP)), add = TRUE)
# abline(v = c(0,tmP/100), col = "orange", lwd = 2, lty = 2)
# points(dP$Tdp, dP$Idp, col = "black", pch = 16)
# legend("bottomleft", legend = rownames(dP), lty = 1, lwd = 2,col = rainbow(nrow(dP)))
# Union des matrix
dP$con <- as.numeric(Cvoc[k])
dP$seq <- VOCseq
# mise en forme
colnames(matS) <- paste0("T_",Tp) # le temps
fmr <- !is.na(matS[1,]) # pour le calcul du temps lors de la partie eag ci-dessus ... ouais c'est pas ouf
matS <- matS[,!is.na(matS[1,])] # suppression des vagues du au lissage
resM <- rbind(resM,cbind(dP[,5:8], matS)) # maj de la matrice
}
depol <- resM[,1:4] # on garde l'intensité et le temps de depol, ainsi que la concentration et le VOC
depol$con[which(depol$seq == control)] <- 0 # mise a zero des temoins
depol$con <- as.character(depol$con) %>% as.factor() # les numeriques posent preobleme pour le graphe
depol$seq <- as.factor(depol$seq) # facteur
depol$variable <- rownames(depol) # pour le graphe
depol
# Importation du fichier EAG ####
eag <- read.csv(paste0(wd,"/",Sname,".csv"))[,-(1:2)] # import du fichier EAG
neag <- ncol(eag)/3  # nombre de signaux EAG
fmr <- which(Sname == expdes$File) # index dans le plan d'experience
Cvoc <- expdes$VOCconcentration[fmr] # Concentrations associees
Svoc <- expdes$VOCseq[fmr] # sequences VOC associees
# Traitement de chaque signal ####
resM <- NULL # matrice des resultats
resM
k=1
neag
# index effectif du fichier signal
i <- seq(length.out = neag,by = 3)[k]
# La sequence VOC
VOCseq <- str_squish(Svoc[k]) %>% str_split(" ") %>% unlist()
VOCseq
# Traitement de chaque signal ####
resM <- NULL # matrice des resultats
for(k in 1:neag){ # k=1
# index effectif du fichier signal
i <- seq(length.out = neag,by = 3)[k]
# La sequence VOC
VOCseq <- str_squish(Svoc[k]) %>% str_split(" ") %>% unlist()
# recherche des pulses
pulse <- eag[,i+2] - c(eag[-1,i+2],-0.5)
dP <- data.frame(str = which(pulse == -1),
end = which(pulse == -1)+tmP) # position des pulses start et end
if(length(VOCseq) != nrow(dP) ) stop("The 'VOC sequence' of experimental design does not correspond to the number of pulses")
# name pulse
rownames(dP) <- paste0(VOCseq, ave(VOCseq, VOCseq, FUN = seq), "_c",Cvoc[k])
# calcules preliminaires
dP$X1 <- dP$str - 2*tmP # un blanc anterieur au pulse d'une duree deux fois plus longue que le pulse
dP$X2 <- dP$end + 2*tmP # idem pour le blanc ulterieur
dP$Idp <- rep(NA,nrow(dP)) # NA pour l'intensite de la depolarisation
dP$Tdp <- rep(NA,nrow(dP)) # NA pour la duree de depolaristation
matP <- matrix(NA,nrow(dP),length(dP$X1[1]:dP$X2[1])) # une matrix pour l'EAG brut du pulse elargie
matS <- matP # la meme pour le signal EAG lissee
# chaque peuf
for(j in 1:nrow(dP)) { #j=1 # pour chaque pulse de la sequence
# preparation des matrix signals
IndP <- dP$X1[j]:dP$X2[j] # les index du pulse elargie
matS[j,] <- savgol(eag[IndP,i],ws) # lissage
fmr <- matS[j,2*tmP+1] # le shift a T0
matS[j,] <- matS[j,] - fmr # suppression du shift
matP[j,] <- eag[IndP,i] - fmr # idem pour l'EAG non lissee
# caracterisation de l'impuslion
Ips <- (2*tmP):(2*tmP + 2*tmP) # de T0 à T0+2x la duree du pulse du VOC
dP$Idp[j] <- min(matS[j,Ips]) # l'intensite max de la depol
dP$Tdp[j] <- (which.min(matS[j,Ips])-2)/100 # sa duree
}
# Nettoyage des donnees
matS[,1:((ws-1)/2)] <- NA # suppression des vagues induites par le lissage
matS[,(ncol(matS)-((ws-1)/2)):ncol(matS)] <- NA # idem pour la fin du signal
Tp <- dP$X1[j]:dP$X2[j] - dP$str[j]# le temps recentre
# # Graphe control
# matplot(Tp/100,t(matS), type = "l", lwd = 2, lty = 1, col = rainbow(nrow(dP)),
#         xlab = "Time (s)", ylab = "EAG (mA)", main = paste(Sname,"\nC =",Cvoc[k]))
# matplot(Tp/100,t(matP), type = "l", lwd = 1, lty = 1, col = rainbow(nrow(dP)), add = TRUE)
# abline(v = c(0,tmP/100), col = "orange", lwd = 2, lty = 2)
# points(dP$Tdp, dP$Idp, col = "black", pch = 16)
# legend("bottomleft", legend = rownames(dP), lty = 1, lwd = 2,col = rainbow(nrow(dP)))
# Union des matrix
dP$con <- as.numeric(Cvoc[k])
dP$seq <- VOCseq
# mise en forme
colnames(matS) <- paste0("T_",Tp) # le temps
fmr <- !is.na(matS[1,]) # pour le calcul du temps lors de la partie eag ci-dessus ... ouais c'est pas ouf
matS <- matS[,!is.na(matS[1,])] # suppression des vagues du au lissage
resM <- rbind(resM,cbind(dP[,5:8], matS)) # maj de la matrice
}
depol <- resM[,1:4] # on garde l'intensité et le temps de depol, ainsi que la concentration et le VOC
depol$con[which(depol$seq == control)] <- 0 # mise a zero des temoins
depol$con <- as.character(depol$con) %>% as.factor() # les numeriques posent preobleme pour le graphe
depol$seq <- as.factor(depol$seq) # facteur
depol$variable <- rownames(depol) # pour le graphe
depol
which(depol$seq == control)
# Mise en forme finale ####
i_ctrl <- which(depol$seq == control)
depol <- resM[,1:4] # on garde l'intensité et le temps de depol, ainsi que la concentration et le VOC
depol <- resM[,1:4] # on garde l'intensité et le temps de depol, ainsi que la concentration et le VOC
i_ctrl <- which(depol$seq == control) # l'index des controls
i_ctrl
depol$con[i_ctrl] <- 0 # mise a zero des temoins
depol$con <- as.character(depol$con) %>% as.factor() # les numeriques posent probleme pour le graphe
depol$seq <- as.factor(depol$seq) # facteur
depol$variable <- rownames(depol) # pour le graphe
depol$Idp
abs(depol$Idp)
depol$Idp <- abs(depol$Idp)
mean(depol$Idp[i_ctrl])
depol$Idp - mean(depol$Idp[i_ctrl])
depol <- resM[,1:4] # on garde l'intensité et le temps de depol, ainsi que la concentration et le VOC
i_ctrl <- which(depol$seq == control) # l'index des controls
depol$con[i_ctrl] <- 0 # mise a zero des temoins
depol$con <- as.character(depol$con) %>% as.factor() # les numeriques posent probleme pour le graphe
depol$seq <- as.factor(depol$seq) # facteur
depol$variable <- rownames(depol) # pour le graphe
depol$Idp_adj <- abs(depol$Idp)
depol$Idp_adj <- depol$Idp - mean(depol$Idp[i_ctrl])
depol
depol$Idp_adj <- abs(depol$Idp)
depol$Idp_adj <- depol$Idp_adj - mean(depol$Idp_adj[i_ctrl])
depol
depol$Idp_adj[i_ctrl] <- 0
depol
eag <- data.frame(time = Tp[fmr]/100, t(resM[,-(1:4)])) # data
setDT(eag) # transformation en data.table (???)
Teag <- melt(eag, id.vars = "time") # mise en forme pour plotly
Teag$seq <- Teag$variable # ajout de la sequence des VOC
levels(Teag$seq) <- depol$seq
Teag$con <- Teag$variable # ajout des concentrations
levels(Teag$con) <- depol$con
eag.import <- function(Sname, control = "T", tmP = 50, wd = NULL, ws =25){
# check ####
if (is.null(wd) == TRUE) wd <- getwd()
if (!is.character(wd)) stop("'wd' must be character")
if (("figures" %in% dir(wd))==FALSE) dir.create(paste0(wd,"/figures"))
if (!is.character(Sname)) stop("'Sname' must be character")
if (!is.numeric(ws)) stop("'ws' must be numeric")
if (!is.numeric(tmP)) stop("'tmP' must be numeric")
if (!is.character(control)) stop("'control' must be a character")
if (length(ws) != 1) stop("Length of 'ws' must be 1.")
if (length(tmP) != 1) stop("Length of 'tmP' must be 1.")
if (length(control) != 1) stop("Length of 'control' must be 1.")
# Importation du fichier EAG ####
eag <- read.csv(paste0(wd,"/",Sname,".csv"))[,-(1:2)] # import du fichier EAG
neag <- ncol(eag)/3  # nombre de signaux EAG
fmr <- which(Sname == expdes$File) # index dans le plan d'experience
Cvoc <- expdes$VOCconcentration[fmr] # Concentrations associees
Svoc <- expdes$VOCseq[fmr] # sequences VOC associees
# Traitement de chaque signal ####
resM <- NULL # matrice des resultats
for(k in 1:neag){ # k=1
# index effectif du fichier signal
i <- seq(length.out = neag,by = 3)[k]
# La sequence VOC
VOCseq <- str_squish(Svoc[k]) %>% str_split(" ") %>% unlist()
# recherche des pulses
pulse <- eag[,i+2] - c(eag[-1,i+2],-0.5)
dP <- data.frame(str = which(pulse == -1),
end = which(pulse == -1)+tmP) # position des pulses start et end
if(length(VOCseq) != nrow(dP) ) stop("The 'VOC sequence' of experimental design does not correspond to the number of pulses")
# name pulse
rownames(dP) <- paste0(VOCseq, ave(VOCseq, VOCseq, FUN = seq), "_c",Cvoc[k])
# calcules preliminaires
dP$X1 <- dP$str - 2*tmP # un blanc anterieur au pulse d'une duree deux fois plus longue que le pulse
dP$X2 <- dP$end + 2*tmP # idem pour le blanc ulterieur
dP$Idp <- rep(NA,nrow(dP)) # NA pour l'intensite de la depolarisation
dP$Tdp <- rep(NA,nrow(dP)) # NA pour la duree de depolaristation
matP <- matrix(NA,nrow(dP),length(dP$X1[1]:dP$X2[1])) # une matrix pour l'EAG brut du pulse elargie
matS <- matP # la meme pour le signal EAG lissee
# chaque peuf
for(j in 1:nrow(dP)) { #j=1 # pour chaque pulse de la sequence
# preparation des matrix signals
IndP <- dP$X1[j]:dP$X2[j] # les index du pulse elargie
matS[j,] <- savgol(eag[IndP,i],ws) # lissage
fmr <- matS[j,2*tmP+1] # le shift a T0
matS[j,] <- matS[j,] - fmr # suppression du shift
matP[j,] <- eag[IndP,i] - fmr # idem pour l'EAG non lissee
# caracterisation de l'impuslion
Ips <- (2*tmP):(2*tmP + 2*tmP) # de T0 à T0+2x la duree du pulse du VOC
dP$Idp[j] <- min(matS[j,Ips]) # l'intensite max de la depol
dP$Tdp[j] <- (which.min(matS[j,Ips])-2)/100 # sa duree
}
# Nettoyage des donnees
matS[,1:((ws-1)/2)] <- NA # suppression des vagues induites par le lissage
matS[,(ncol(matS)-((ws-1)/2)):ncol(matS)] <- NA # idem pour la fin du signal
Tp <- dP$X1[j]:dP$X2[j] - dP$str[j]# le temps recentre
# # Graphe control
# matplot(Tp/100,t(matS), type = "l", lwd = 2, lty = 1, col = rainbow(nrow(dP)),
#         xlab = "Time (s)", ylab = "EAG (mA)", main = paste(Sname,"\nC =",Cvoc[k]))
# matplot(Tp/100,t(matP), type = "l", lwd = 1, lty = 1, col = rainbow(nrow(dP)), add = TRUE)
# abline(v = c(0,tmP/100), col = "orange", lwd = 2, lty = 2)
# points(dP$Tdp, dP$Idp, col = "black", pch = 16)
# legend("bottomleft", legend = rownames(dP), lty = 1, lwd = 2,col = rainbow(nrow(dP)))
# Union des matrix
dP$con <- as.numeric(Cvoc[k])
dP$seq <- VOCseq
# mise en forme
colnames(matS) <- paste0("T_",Tp) # le temps
fmr <- !is.na(matS[1,]) # pour le calcul du temps lors de la partie eag ci-dessus ... ouais c'est pas ouf
matS <- matS[,!is.na(matS[1,])] # suppression des vagues du au lissage
resM <- rbind(resM,cbind(dP[,5:8], matS)) # maj de la matrice
}
# Mise en forme finale ####
depol <- resM[,1:4] # on garde l'intensité et le temps de depol, ainsi que la concentration et le VOC
i_ctrl <- which(depol$seq == control) # l'index des controls
depol$con[i_ctrl] <- 0 # mise a zero des temoins
depol$con <- as.character(depol$con) %>% as.factor() # les numeriques posent probleme pour le graphe
depol$seq <- as.factor(depol$seq) # facteur
depol$variable <- rownames(depol) # pour le graphe
depol$Idp_adj <- abs(depol$Idp)
depol$Idp_adj[i_ctrl] <- 0
eag <- data.frame(time = Tp[fmr]/100, t(resM[,-(1:4)])) # data
setDT(eag) # transformation en data.table (???)
Teag <- melt(eag, id.vars = "time") # mise en forme pour plotly
Teag$seq <- Teag$variable # ajout de la sequence des VOC
levels(Teag$seq) <- depol$seq
Teag$con <- Teag$variable # ajout des concentrations
levels(Teag$con) <- depol$con
# Graphes ####
### by Concentration
fig <- plot_ly(Teag, type = "scatter", mode = "lines", x = ~time, y = ~value,
color = ~con, name = ~variable)
fig <- plotly::layout(fig, title = Sname,
shapes = list(list(type = "line", y0 = 0, y1 = 1, yref = "paper",
x0 = 0, x1 = 0, line = list(color = "orange", dash="dot")),
list(type = "line", y0 = 0, y1 = 1, yref = "paper",
x0 = tmP/100, x1 = tmP/100, line = list(color = "orange", dash="dot"))),
xaxis = list(title = 'Time (sec)'),
yaxis = list(title = 'EAG (mA)'),
legend = list(title=list(text='<b> VOC_concentration </b>'), x = 0.02, y = 0.9))
fig <- add_markers(fig, x = ~Tdp, y = ~Idp, data = depol, showlegend= FALSE)
# print(fig)
htmlwidgets::saveWidget(fig, paste0(wd,"/figures/options_graph_dy.html"), selfcontained = TRUE)
file.rename(from = paste0(wd,"/figures/options_graph_dy.html"),
to = paste0(wd,"/figures/",Sname,"_by_concentration.html"))
### by VOC
fig <- plot_ly(Teag, type = "scatter", mode = "lines", x = ~time, y = ~value,
color = ~seq, name = ~variable)
fig <- plotly::layout(fig, title = Sname,
shapes = list(list(type = "line", y0 = 0, y1 = 1, yref = "paper",
x0 = 0, x1 = 0, line = list(color = "orange", dash="dot")),
list(type = "line", y0 = 0, y1 = 1, yref = "paper",
x0 = tmP/100, x1 = tmP/100, line = list(color = "orange", dash="dot"))),
xaxis = list(title = 'Time (sec)'),
yaxis = list(title = 'EAG (mA)'),
legend = list(title=list(text='<b> VOC_concentration </b>'),
x = 0.02, y = 0.9))
fig <- add_markers(fig, x = ~Tdp, y = ~Idp, data = depol, showlegend= FALSE)
# print(fig)
htmlwidgets::saveWidget(fig, paste0(wd,"/figures/options_graph_dy.html"), selfcontained = TRUE)
file.rename(from = paste0(wd,"/figures/options_graph_dy.html"),
to = paste0(wd,"/figures/",Sname,"_by_VOC.html"))
# Export ####
return(new(Class = "eag", depol = depol, eag = eag, tmP = tmP, wd = wd, names = Sname))
}
expdes
B_137 <- eag.import(Sname = "Bombus137_C_0ppb_1h", wd = wod)
B_170 <- eag.import(Sname = "Bombus170_C_0ppb_1h", wd = wod)
B_171 <- eag.import(Sname = "Bombus171_C_0ppb_1h", wd = wod)
B_172 <- eag.import(Sname = "Bombus172_C_0ppb_1h", wd = wod)
Sname <- c("B_137","B_170","B_171","B_172")
Meag <- eag.merge(B_137, B_170, B_171, B_172, eag_names = Sname)
View(Meag@depol)
eag = Meag
# check
if (class(eag) != "eag") stop("eag must be a eag S4 object")
if (!is.character(moda)) stop("'moda' must be character")
if (("figures" %in% dir(wd))==FALSE) dir.create(paste0(wd,"/figures"))
if (length(moda) != 1) stop("Length of 'moda' must be 1.")
im <- match(moda,colnames(eag@depol))
moda = "seq"
# check
if (class(eag) != "eag") stop("eag must be a eag S4 object")
if (!is.character(moda)) stop("'moda' must be character")
if (("figures" %in% dir(wd))==FALSE) dir.create(paste0(wd,"/figures"))
if (length(moda) != 1) stop("Length of 'moda' must be 1.")
im <- match(moda,colnames(eag@depol))
if (is.na(im)) stop("moda must be a vector of eag@depol")
# Mise en forme ####
Teag <- melt(eag@eag, id.vars = "time") # mise en forme pour plotly
Teag$moda <- Teag$variable # ajout de la sequence des VOC
levels(Teag$moda) <- eag@depol[,im]
eag@depol$moda <- eag@depol[,im]
eag@eag
dim(eag@eag)
eag@depol$seq
eag@tmP
eag@names
eag@depol
delet_con = NULL
class(delet_con)
is.null(delet_con)
if (is.null(delet_con)|is.character(delet_con)) print("ok")
if (!is.null(delet_con)|!is.character(delet_con)) print("ok")
if (!is.null(delet_con)) if(!is.character(delet_con)) print("ok")
colnames(eag@depol)
eag@con
eag@depol$con
levels(eag@depol$con)
delet_con %in% levels(eag@depol$con)
delet_con <- "0"
delet_con %in% levels(eag@depol$con)
delet_con <- c("0","T")
delet_con %in% levels(eag@depol$con)
delet_con %in% levels(eag@depol$con) %>% is.FALSE()
delet_con %in% levels(eag@depol$con) %>% isFALSE()
delet_con %in% levels(eag@depol$con) %>% isTRUE()
delet_con <- c("0")
delet_con %in% levels(eag@depol$con) %>% isTRUE()
if (is.character(delet_con)) if(delet_con %in% levels(eag@depol$con) %>% isTRUE()) print("ok")
if (is.character(delet_con)) if(delet_con %in% levels(eag@depol$con) %>% !isTRUE()) print("ok")
if (is.character(delet_con)) if(delet_con %in% levels(eag@depol$con) %>% isFALSE()) print("ok")
delet_con <- c("0","1")
delet_con <- c("0","1")
if (is.character(delet_con)) if(delet_con %in% levels(eag@depol$con) %>% isFALSE()) print("ok")
delet_con <- c("0","T")
if (is.character(delet_con)) if(delet_con %in% levels(eag@depol$con) %>% isFALSE()) print("ok")
if (is.character(delet_con)) if(delet_con %in% levels(eag@depol$con)) print("ok")
match(delet_con, levels(eag@depol$con))
mean(delet_con %in% levels(eag@depol$con))
if (is.character(delet_con)) if(mean(delet_con %in% levels(eag@depol$con)) != 1) print("ok")
delet_con <- c("0","1")
if (is.character(delet_con)) if(mean(delet_con %in% levels(eag@depol$con)) != 1) print("ok")
delet_con <- c("0")
if (is.character(delet_con)) if(mean(delet_con %in% levels(eag@depol$con)) != 1) print("ok")
delet_seq <- c("T")
if (!is.null(delet_con)) if (!is.character(delet_con)) stop("'delet_con' must be null or a character")
if (!is.null(delet_seq)) if (!is.character(delet_seq)) stop("'delet_seq' must be null or a character")
if (is.character(delet_con)) if(mean(delet_con %in% levels(eag@depol$con)) != 1) stop("'delet_con' isn't a level of experimental design")
if (is.character(delet_seq)) if(mean(delet_seq %in% levels(eag@depol$seq)) != 1) stop("'delet_seq' isn't a level of experimental design")
delet_seq <- c("T","1")
if (!is.null(delet_seq)) if (!is.character(delet_seq)) stop("'delet_seq' must be null or a character")
if (is.character(delet_con)) if(mean(delet_con %in% levels(eag@depol$con)) != 1) stop("'delet_con' isn't a level of experimental design")
if (is.character(delet_seq)) if(mean(delet_seq %in% levels(eag@depol$seq)) != 1) stop("'delet_seq' isn't a level of experimental design")
dim(eag@eag)
dim(eag@depol)
colnames(eag@eag)
match(delet_con,eag@depol$con)
# import
wod <- "C:/Users/huguenin/Documents/R/rEAG_test"
setwd(wod)
save.image("~/R/rEAG_test/rEAG_test_2.RData")
